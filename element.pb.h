// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: element.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_element_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_element_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_element_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_element_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_element_2eproto;
namespace protobuf {
class Circle;
struct CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class Comment;
struct CommentDefaultTypeInternal;
extern CommentDefaultTypeInternal _Comment_default_instance_;
class Common;
struct CommonDefaultTypeInternal;
extern CommonDefaultTypeInternal _Common_default_instance_;
class Element;
struct ElementDefaultTypeInternal;
extern ElementDefaultTypeInternal _Element_default_instance_;
class Line;
struct LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Picture;
struct PictureDefaultTypeInternal;
extern PictureDefaultTypeInternal _Picture_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Square;
struct SquareDefaultTypeInternal;
extern SquareDefaultTypeInternal _Square_default_instance_;
class StickyNote;
struct StickyNoteDefaultTypeInternal;
extern StickyNoteDefaultTypeInternal _StickyNote_default_instance_;
class Text;
struct TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
class Triangle;
struct TriangleDefaultTypeInternal;
extern TriangleDefaultTypeInternal _Triangle_default_instance_;
}  // namespace protobuf
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace protobuf {

// ===================================================================


// -------------------------------------------------------------------

class Point final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Point(::google::protobuf::internal::ConstantInitialized);

  inline Point(const Point& from)
      : Point(nullptr, from) {}
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Point* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Point";
  }
  protected:
  explicit Point(::google::protobuf::Arena* arena);
  Point(::google::protobuf::Arena* arena, const Point& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Point)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Common final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Common) */ {
 public:
  inline Common() : Common(nullptr) {}
  ~Common() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Common(::google::protobuf::internal::ConstantInitialized);

  inline Common(const Common& from)
      : Common(nullptr, from) {}
  Common(Common&& from) noexcept
    : Common() {
    *this = ::std::move(from);
  }

  inline Common& operator=(const Common& from) {
    CopyFrom(from);
    return *this;
  }
  inline Common& operator=(Common&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Common& default_instance() {
    return *internal_default_instance();
  }
  static inline const Common* internal_default_instance() {
    return reinterpret_cast<const Common*>(
               &_Common_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Common& a, Common& b) {
    a.Swap(&b);
  }
  inline void Swap(Common* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Common* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Common* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Common>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Common& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Common& from) {
    Common::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Common* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Common";
  }
  protected:
  explicit Common(::google::protobuf::Arena* arena);
  Common(::google::protobuf::Arena* arena, const Common& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStrokeColorFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string stroke_color = 2;
  void clear_stroke_color() ;
  const std::string& stroke_color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stroke_color(Arg_&& arg, Args_... args);
  std::string* mutable_stroke_color();
  PROTOBUF_NODISCARD std::string* release_stroke_color();
  void set_allocated_stroke_color(std::string* value);

  private:
  const std::string& _internal_stroke_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stroke_color(
      const std::string& value);
  std::string* _internal_mutable_stroke_color();

  public:
  // string user_id = 3;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Common)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr stroke_color_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Comment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Comment) */ {
 public:
  inline Comment() : Comment(nullptr) {}
  ~Comment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Comment(::google::protobuf::internal::ConstantInitialized);

  inline Comment(const Comment& from)
      : Comment(nullptr, from) {}
  Comment(Comment&& from) noexcept
    : Comment() {
    *this = ::std::move(from);
  }

  inline Comment& operator=(const Comment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Comment& operator=(Comment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Comment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Comment* internal_default_instance() {
    return reinterpret_cast<const Comment*>(
               &_Comment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Comment& a, Comment& b) {
    a.Swap(&b);
  }
  inline void Swap(Comment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Comment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Comment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Comment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Comment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Comment& from) {
    Comment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Comment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Comment";
  }
  protected:
  explicit Comment(::google::protobuf::Arena* arena);
  Comment(::google::protobuf::Arena* arena, const Comment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string content = 2;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Comment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Triangle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Triangle) */ {
 public:
  inline Triangle() : Triangle(nullptr) {}
  ~Triangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Triangle(::google::protobuf::internal::ConstantInitialized);

  inline Triangle(const Triangle& from)
      : Triangle(nullptr, from) {}
  Triangle(Triangle&& from) noexcept
    : Triangle() {
    *this = ::std::move(from);
  }

  inline Triangle& operator=(const Triangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Triangle& operator=(Triangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Triangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Triangle* internal_default_instance() {
    return reinterpret_cast<const Triangle*>(
               &_Triangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Triangle& a, Triangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Triangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Triangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Triangle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Triangle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Triangle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Triangle& from) {
    Triangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Triangle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Triangle";
  }
  protected:
  explicit Triangle(::google::protobuf::Arena* arena);
  Triangle(::google::protobuf::Arena* arena, const Triangle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kPoint1FieldNumber = 2,
    kPoint2FieldNumber = 3,
    kPoint3FieldNumber = 4,
  };
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point point1 = 2;
  bool has_point1() const;
  void clear_point1() ;
  const ::protobuf::Point& point1() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_point1();
  ::protobuf::Point* mutable_point1();
  void set_allocated_point1(::protobuf::Point* value);
  void unsafe_arena_set_allocated_point1(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_point1();

  private:
  const ::protobuf::Point& _internal_point1() const;
  ::protobuf::Point* _internal_mutable_point1();

  public:
  // .protobuf.Point point2 = 3;
  bool has_point2() const;
  void clear_point2() ;
  const ::protobuf::Point& point2() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_point2();
  ::protobuf::Point* mutable_point2();
  void set_allocated_point2(::protobuf::Point* value);
  void unsafe_arena_set_allocated_point2(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_point2();

  private:
  const ::protobuf::Point& _internal_point2() const;
  ::protobuf::Point* _internal_mutable_point2();

  public:
  // .protobuf.Point point3 = 4;
  bool has_point3() const;
  void clear_point3() ;
  const ::protobuf::Point& point3() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_point3();
  ::protobuf::Point* mutable_point3();
  void set_allocated_point3(::protobuf::Point* value);
  void unsafe_arena_set_allocated_point3(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_point3();

  private:
  const ::protobuf::Point& _internal_point3() const;
  ::protobuf::Point* _internal_mutable_point3();

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Triangle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protobuf::Common* common_;
    ::protobuf::Point* point1_;
    ::protobuf::Point* point2_;
    ::protobuf::Point* point3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Text final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Text) */ {
 public:
  inline Text() : Text(nullptr) {}
  ~Text() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Text(::google::protobuf::internal::ConstantInitialized);

  inline Text(const Text& from)
      : Text(nullptr, from) {}
  Text(Text&& from) noexcept
    : Text() {
    *this = ::std::move(from);
  }

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Text& default_instance() {
    return *internal_default_instance();
  }
  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
               &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Text& a, Text& b) {
    a.Swap(&b);
  }
  inline void Swap(Text* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Text* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Text* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Text>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Text& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Text& from) {
    Text::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Text* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Text";
  }
  protected:
  explicit Text(::google::protobuf::Arena* arena);
  Text(::google::protobuf::Arena* arena, const Text& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kCommonFieldNumber = 1,
    kCenterFieldNumber = 2,
  };
  // string content = 3;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protobuf::Point& center() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_center();
  ::protobuf::Point* mutable_center();
  void set_allocated_center(::protobuf::Point* value);
  void unsafe_arena_set_allocated_center(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_center();

  private:
  const ::protobuf::Point& _internal_center() const;
  ::protobuf::Point* _internal_mutable_center();

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Text)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::protobuf::Common* common_;
    ::protobuf::Point* center_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class StickyNote final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.StickyNote) */ {
 public:
  inline StickyNote() : StickyNote(nullptr) {}
  ~StickyNote() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StickyNote(::google::protobuf::internal::ConstantInitialized);

  inline StickyNote(const StickyNote& from)
      : StickyNote(nullptr, from) {}
  StickyNote(StickyNote&& from) noexcept
    : StickyNote() {
    *this = ::std::move(from);
  }

  inline StickyNote& operator=(const StickyNote& from) {
    CopyFrom(from);
    return *this;
  }
  inline StickyNote& operator=(StickyNote&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StickyNote& default_instance() {
    return *internal_default_instance();
  }
  static inline const StickyNote* internal_default_instance() {
    return reinterpret_cast<const StickyNote*>(
               &_StickyNote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StickyNote& a, StickyNote& b) {
    a.Swap(&b);
  }
  inline void Swap(StickyNote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StickyNote* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StickyNote* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StickyNote>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StickyNote& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StickyNote& from) {
    StickyNote::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StickyNote* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.StickyNote";
  }
  protected:
  explicit StickyNote(::google::protobuf::Arena* arena);
  StickyNote(::google::protobuf::Arena* arena, const StickyNote& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 4,
    kCommonFieldNumber = 1,
    kCenterFieldNumber = 2,
    kSideLengthFieldNumber = 3,
  };
  // string content = 4;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protobuf::Point& center() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_center();
  ::protobuf::Point* mutable_center();
  void set_allocated_center(::protobuf::Point* value);
  void unsafe_arena_set_allocated_center(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_center();

  private:
  const ::protobuf::Point& _internal_center() const;
  ::protobuf::Point* _internal_mutable_center();

  public:
  // float side_length = 3;
  void clear_side_length() ;
  float side_length() const;
  void set_side_length(float value);

  private:
  float _internal_side_length() const;
  void _internal_set_side_length(float value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.StickyNote)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::protobuf::Common* common_;
    ::protobuf::Point* center_;
    float side_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Square final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Square) */ {
 public:
  inline Square() : Square(nullptr) {}
  ~Square() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Square(::google::protobuf::internal::ConstantInitialized);

  inline Square(const Square& from)
      : Square(nullptr, from) {}
  Square(Square&& from) noexcept
    : Square() {
    *this = ::std::move(from);
  }

  inline Square& operator=(const Square& from) {
    CopyFrom(from);
    return *this;
  }
  inline Square& operator=(Square&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Square& default_instance() {
    return *internal_default_instance();
  }
  static inline const Square* internal_default_instance() {
    return reinterpret_cast<const Square*>(
               &_Square_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Square& a, Square& b) {
    a.Swap(&b);
  }
  inline void Swap(Square* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Square* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Square* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Square>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Square& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Square& from) {
    Square::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Square* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Square";
  }
  protected:
  explicit Square(::google::protobuf::Arena* arena);
  Square(::google::protobuf::Arena* arena, const Square& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kTopleftFieldNumber = 2,
    kSideLengthFieldNumber = 3,
  };
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point topleft = 2;
  bool has_topleft() const;
  void clear_topleft() ;
  const ::protobuf::Point& topleft() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_topleft();
  ::protobuf::Point* mutable_topleft();
  void set_allocated_topleft(::protobuf::Point* value);
  void unsafe_arena_set_allocated_topleft(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_topleft();

  private:
  const ::protobuf::Point& _internal_topleft() const;
  ::protobuf::Point* _internal_mutable_topleft();

  public:
  // float side_length = 3;
  void clear_side_length() ;
  float side_length() const;
  void set_side_length(float value);

  private:
  float _internal_side_length() const;
  void _internal_set_side_length(float value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Square)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protobuf::Common* common_;
    ::protobuf::Point* topleft_;
    float side_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Picture final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Picture) */ {
 public:
  inline Picture() : Picture(nullptr) {}
  ~Picture() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Picture(::google::protobuf::internal::ConstantInitialized);

  inline Picture(const Picture& from)
      : Picture(nullptr, from) {}
  Picture(Picture&& from) noexcept
    : Picture() {
    *this = ::std::move(from);
  }

  inline Picture& operator=(const Picture& from) {
    CopyFrom(from);
    return *this;
  }
  inline Picture& operator=(Picture&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Picture& default_instance() {
    return *internal_default_instance();
  }
  static inline const Picture* internal_default_instance() {
    return reinterpret_cast<const Picture*>(
               &_Picture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Picture& a, Picture& b) {
    a.Swap(&b);
  }
  inline void Swap(Picture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Picture* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Picture* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Picture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Picture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Picture& from) {
    Picture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Picture* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Picture";
  }
  protected:
  explicit Picture(::google::protobuf::Arena* arena);
  Picture(::google::protobuf::Arena* arena, const Picture& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentsFieldNumber = 6,
    kFileNameFieldNumber = 2,
    kDataFieldNumber = 5,
    kCommonFieldNumber = 1,
    kCenterFieldNumber = 3,
    kTopSideLengthFieldNumber = 4,
  };
  // repeated .protobuf.Comment comments = 6;
  int comments_size() const;
  private:
  int _internal_comments_size() const;

  public:
  void clear_comments() ;
  ::protobuf::Comment* mutable_comments(int index);
  ::google::protobuf::RepeatedPtrField< ::protobuf::Comment >*
      mutable_comments();
  private:
  const ::google::protobuf::RepeatedPtrField<::protobuf::Comment>& _internal_comments() const;
  ::google::protobuf::RepeatedPtrField<::protobuf::Comment>* _internal_mutable_comments();
  public:
  const ::protobuf::Comment& comments(int index) const;
  ::protobuf::Comment* add_comments();
  const ::google::protobuf::RepeatedPtrField< ::protobuf::Comment >&
      comments() const;
  // string file_name = 2;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // bytes data = 5;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point center = 3;
  bool has_center() const;
  void clear_center() ;
  const ::protobuf::Point& center() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_center();
  ::protobuf::Point* mutable_center();
  void set_allocated_center(::protobuf::Point* value);
  void unsafe_arena_set_allocated_center(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_center();

  private:
  const ::protobuf::Point& _internal_center() const;
  ::protobuf::Point* _internal_mutable_center();

  public:
  // float top_side_length = 4;
  void clear_top_side_length() ;
  float top_side_length() const;
  void set_top_side_length(float value);

  private:
  float _internal_top_side_length() const;
  void _internal_set_top_side_length(float value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Picture)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::protobuf::Comment > comments_;
    ::google::protobuf::internal::ArenaStringPtr file_name_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::protobuf::Common* common_;
    ::protobuf::Point* center_;
    float top_side_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Path final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Path(::google::protobuf::internal::ConstantInitialized);

  inline Path(const Path& from)
      : Path(nullptr, from) {}
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Path& from) {
    Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Path* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Path";
  }
  protected:
  explicit Path(::google::protobuf::Arena* arena);
  Path(::google::protobuf::Arena* arena, const Path& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kCommonFieldNumber = 1,
  };
  // repeated .protobuf.Point points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::protobuf::Point* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::protobuf::Point >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::protobuf::Point>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::protobuf::Point>* _internal_mutable_points();
  public:
  const ::protobuf::Point& points(int index) const;
  ::protobuf::Point* add_points();
  const ::google::protobuf::RepeatedPtrField< ::protobuf::Point >&
      points() const;
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Path)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::protobuf::Point > points_;
    ::protobuf::Common* common_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Line final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Line) */ {
 public:
  inline Line() : Line(nullptr) {}
  ~Line() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Line(::google::protobuf::internal::ConstantInitialized);

  inline Line(const Line& from)
      : Line(nullptr, from) {}
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Line& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Line& from) {
    Line::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Line* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Line";
  }
  protected:
  explicit Line(::google::protobuf::Arena* arena);
  Line(::google::protobuf::Arena* arena, const Line& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point start = 2;
  bool has_start() const;
  void clear_start() ;
  const ::protobuf::Point& start() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_start();
  ::protobuf::Point* mutable_start();
  void set_allocated_start(::protobuf::Point* value);
  void unsafe_arena_set_allocated_start(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_start();

  private:
  const ::protobuf::Point& _internal_start() const;
  ::protobuf::Point* _internal_mutable_start();

  public:
  // .protobuf.Point end = 3;
  bool has_end() const;
  void clear_end() ;
  const ::protobuf::Point& end() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_end();
  ::protobuf::Point* mutable_end();
  void set_allocated_end(::protobuf::Point* value);
  void unsafe_arena_set_allocated_end(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_end();

  private:
  const ::protobuf::Point& _internal_end() const;
  ::protobuf::Point* _internal_mutable_end();

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Line)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protobuf::Common* common_;
    ::protobuf::Point* start_;
    ::protobuf::Point* end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Circle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {}
  ~Circle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Circle(::google::protobuf::internal::ConstantInitialized);

  inline Circle(const Circle& from)
      : Circle(nullptr, from) {}
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Circle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Circle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Circle& from) {
    Circle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Circle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Circle";
  }
  protected:
  explicit Circle(::google::protobuf::Arena* arena);
  Circle(::google::protobuf::Arena* arena, const Circle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kCenterFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // .protobuf.Common common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::protobuf::Common& common() const;
  PROTOBUF_NODISCARD ::protobuf::Common* release_common();
  ::protobuf::Common* mutable_common();
  void set_allocated_common(::protobuf::Common* value);
  void unsafe_arena_set_allocated_common(::protobuf::Common* value);
  ::protobuf::Common* unsafe_arena_release_common();

  private:
  const ::protobuf::Common& _internal_common() const;
  ::protobuf::Common* _internal_mutable_common();

  public:
  // .protobuf.Point center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protobuf::Point& center() const;
  PROTOBUF_NODISCARD ::protobuf::Point* release_center();
  ::protobuf::Point* mutable_center();
  void set_allocated_center(::protobuf::Point* value);
  void unsafe_arena_set_allocated_center(::protobuf::Point* value);
  ::protobuf::Point* unsafe_arena_release_center();

  private:
  const ::protobuf::Point& _internal_center() const;
  ::protobuf::Point* _internal_mutable_center();

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:protobuf.Circle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protobuf::Common* common_;
    ::protobuf::Point* center_;
    float radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};// -------------------------------------------------------------------

class Element final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.Element) */ {
 public:
  inline Element() : Element(nullptr) {}
  ~Element() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Element(::google::protobuf::internal::ConstantInitialized);

  inline Element(const Element& from)
      : Element(nullptr, from) {}
  Element(Element&& from) noexcept
    : Element() {
    *this = ::std::move(from);
  }

  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }
  inline Element& operator=(Element&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Element& default_instance() {
    return *internal_default_instance();
  }
  enum ElementTypeCase {
    kPath = 1,
    kLine = 2,
    kCircle = 3,
    kTriangle = 4,
    kSquare = 5,
    kText = 6,
    kPicture = 7,
    kStickynote = 8,
    ELEMENT_TYPE_NOT_SET = 0,
  };

  static inline const Element* internal_default_instance() {
    return reinterpret_cast<const Element*>(
               &_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Element& a, Element& b) {
    a.Swap(&b);
  }
  inline void Swap(Element* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Element* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Element* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Element>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Element& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Element& from) {
    Element::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Element* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protobuf.Element";
  }
  protected:
  explicit Element(::google::protobuf::Arena* arena);
  Element(::google::protobuf::Arena* arena, const Element& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kLineFieldNumber = 2,
    kCircleFieldNumber = 3,
    kTriangleFieldNumber = 4,
    kSquareFieldNumber = 5,
    kTextFieldNumber = 6,
    kPictureFieldNumber = 7,
    kStickynoteFieldNumber = 8,
  };
  // .protobuf.Path path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;

  public:
  void clear_path() ;
  const ::protobuf::Path& path() const;
  PROTOBUF_NODISCARD ::protobuf::Path* release_path();
  ::protobuf::Path* mutable_path();
  void set_allocated_path(::protobuf::Path* value);
  void unsafe_arena_set_allocated_path(::protobuf::Path* value);
  ::protobuf::Path* unsafe_arena_release_path();

  private:
  const ::protobuf::Path& _internal_path() const;
  ::protobuf::Path* _internal_mutable_path();

  public:
  // .protobuf.Line line = 2;
  bool has_line() const;
  private:
  bool _internal_has_line() const;

  public:
  void clear_line() ;
  const ::protobuf::Line& line() const;
  PROTOBUF_NODISCARD ::protobuf::Line* release_line();
  ::protobuf::Line* mutable_line();
  void set_allocated_line(::protobuf::Line* value);
  void unsafe_arena_set_allocated_line(::protobuf::Line* value);
  ::protobuf::Line* unsafe_arena_release_line();

  private:
  const ::protobuf::Line& _internal_line() const;
  ::protobuf::Line* _internal_mutable_line();

  public:
  // .protobuf.Circle circle = 3;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;

  public:
  void clear_circle() ;
  const ::protobuf::Circle& circle() const;
  PROTOBUF_NODISCARD ::protobuf::Circle* release_circle();
  ::protobuf::Circle* mutable_circle();
  void set_allocated_circle(::protobuf::Circle* value);
  void unsafe_arena_set_allocated_circle(::protobuf::Circle* value);
  ::protobuf::Circle* unsafe_arena_release_circle();

  private:
  const ::protobuf::Circle& _internal_circle() const;
  ::protobuf::Circle* _internal_mutable_circle();

  public:
  // .protobuf.Triangle triangle = 4;
  bool has_triangle() const;
  private:
  bool _internal_has_triangle() const;

  public:
  void clear_triangle() ;
  const ::protobuf::Triangle& triangle() const;
  PROTOBUF_NODISCARD ::protobuf::Triangle* release_triangle();
  ::protobuf::Triangle* mutable_triangle();
  void set_allocated_triangle(::protobuf::Triangle* value);
  void unsafe_arena_set_allocated_triangle(::protobuf::Triangle* value);
  ::protobuf::Triangle* unsafe_arena_release_triangle();

  private:
  const ::protobuf::Triangle& _internal_triangle() const;
  ::protobuf::Triangle* _internal_mutable_triangle();

  public:
  // .protobuf.Square square = 5;
  bool has_square() const;
  private:
  bool _internal_has_square() const;

  public:
  void clear_square() ;
  const ::protobuf::Square& square() const;
  PROTOBUF_NODISCARD ::protobuf::Square* release_square();
  ::protobuf::Square* mutable_square();
  void set_allocated_square(::protobuf::Square* value);
  void unsafe_arena_set_allocated_square(::protobuf::Square* value);
  ::protobuf::Square* unsafe_arena_release_square();

  private:
  const ::protobuf::Square& _internal_square() const;
  ::protobuf::Square* _internal_mutable_square();

  public:
  // .protobuf.Text text = 6;
  bool has_text() const;
  private:
  bool _internal_has_text() const;

  public:
  void clear_text() ;
  const ::protobuf::Text& text() const;
  PROTOBUF_NODISCARD ::protobuf::Text* release_text();
  ::protobuf::Text* mutable_text();
  void set_allocated_text(::protobuf::Text* value);
  void unsafe_arena_set_allocated_text(::protobuf::Text* value);
  ::protobuf::Text* unsafe_arena_release_text();

  private:
  const ::protobuf::Text& _internal_text() const;
  ::protobuf::Text* _internal_mutable_text();

  public:
  // .protobuf.Picture picture = 7;
  bool has_picture() const;
  private:
  bool _internal_has_picture() const;

  public:
  void clear_picture() ;
  const ::protobuf::Picture& picture() const;
  PROTOBUF_NODISCARD ::protobuf::Picture* release_picture();
  ::protobuf::Picture* mutable_picture();
  void set_allocated_picture(::protobuf::Picture* value);
  void unsafe_arena_set_allocated_picture(::protobuf::Picture* value);
  ::protobuf::Picture* unsafe_arena_release_picture();

  private:
  const ::protobuf::Picture& _internal_picture() const;
  ::protobuf::Picture* _internal_mutable_picture();

  public:
  // .protobuf.StickyNote stickynote = 8;
  bool has_stickynote() const;
  private:
  bool _internal_has_stickynote() const;

  public:
  void clear_stickynote() ;
  const ::protobuf::StickyNote& stickynote() const;
  PROTOBUF_NODISCARD ::protobuf::StickyNote* release_stickynote();
  ::protobuf::StickyNote* mutable_stickynote();
  void set_allocated_stickynote(::protobuf::StickyNote* value);
  void unsafe_arena_set_allocated_stickynote(::protobuf::StickyNote* value);
  ::protobuf::StickyNote* unsafe_arena_release_stickynote();

  private:
  const ::protobuf::StickyNote& _internal_stickynote() const;
  ::protobuf::StickyNote* _internal_mutable_stickynote();

  public:
  void clear_element_type();
  ElementTypeCase element_type_case() const;
  // @@protoc_insertion_point(class_scope:protobuf.Element)
 private:
  class _Internal;
  void set_has_path();
  void set_has_line();
  void set_has_circle();
  void set_has_triangle();
  void set_has_square();
  void set_has_text();
  void set_has_picture();
  void set_has_stickynote();

  inline bool has_element_type() const;
  inline void clear_has_element_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ElementTypeUnion {
      constexpr ElementTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protobuf::Path* path_;
      ::protobuf::Line* line_;
      ::protobuf::Circle* circle_;
      ::protobuf::Triangle* triangle_;
      ::protobuf::Square* square_;
      ::protobuf::Text* text_;
      ::protobuf::Picture* picture_;
      ::protobuf::StickyNote* stickynote_;
    } element_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_element_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Point

// float x = 1;
inline void Point::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:protobuf.Point.x)
  return _internal_x();
}
inline void Point::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protobuf.Point.x)
}
inline float Point::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Point::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Point::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:protobuf.Point.y)
  return _internal_y();
}
inline void Point::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protobuf.Point.y)
}
inline float Point::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Point::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Common

// string id = 1;
inline void Common::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Common::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Common.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Common::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Common.id)
}
inline std::string* Common::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:protobuf.Common.id)
  return _s;
}
inline const std::string& Common::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Common::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Common::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Common::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Common.id)
  return _impl_.id_.Release();
}
inline void Common::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Common.id)
}

// string stroke_color = 2;
inline void Common::clear_stroke_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stroke_color_.ClearToEmpty();
}
inline const std::string& Common::stroke_color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Common.stroke_color)
  return _internal_stroke_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Common::set_stroke_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stroke_color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Common.stroke_color)
}
inline std::string* Common::mutable_stroke_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stroke_color();
  // @@protoc_insertion_point(field_mutable:protobuf.Common.stroke_color)
  return _s;
}
inline const std::string& Common::_internal_stroke_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stroke_color_.Get();
}
inline void Common::_internal_set_stroke_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stroke_color_.Set(value, GetArena());
}
inline std::string* Common::_internal_mutable_stroke_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.stroke_color_.Mutable( GetArena());
}
inline std::string* Common::release_stroke_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Common.stroke_color)
  return _impl_.stroke_color_.Release();
}
inline void Common::set_allocated_stroke_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stroke_color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stroke_color_.IsDefault()) {
          _impl_.stroke_color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Common.stroke_color)
}

// string user_id = 3;
inline void Common::clear_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Common::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Common.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Common::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Common.user_id)
}
inline std::string* Common::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:protobuf.Common.user_id)
  return _s;
}
inline const std::string& Common::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void Common::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* Common::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* Common::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Common.user_id)
  return _impl_.user_id_.Release();
}
inline void Common::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Common.user_id)
}

// -------------------------------------------------------------------

// Path

// .protobuf.Common common = 1;
inline bool Path::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Path::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Path::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Path::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Path.common)
  return _internal_common();
}
inline void Path::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Path.common)
}
inline ::protobuf::Common* Path::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Path::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Path.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Path::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Path::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Path.common)
  return _msg;
}
inline void Path::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Path.common)
}

// repeated .protobuf.Point points = 2;
inline int Path::_internal_points_size() const {
  return _internal_points().size();
}
inline int Path::points_size() const {
  return _internal_points_size();
}
inline void Path::clear_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.points_.Clear();
}
inline ::protobuf::Point* Path::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protobuf.Path.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protobuf::Point>* Path::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protobuf.Path.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::protobuf::Point& Path::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Path.points)
  return _internal_points().Get(index);
}
inline ::protobuf::Point* Path::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protobuf::Point* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:protobuf.Path.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protobuf::Point>& Path::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protobuf.Path.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::protobuf::Point>&
Path::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::protobuf::Point>*
Path::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// -------------------------------------------------------------------

// Line

// .protobuf.Common common = 1;
inline bool Line::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Line::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Line::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Line::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Line.common)
  return _internal_common();
}
inline void Line::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Line.common)
}
inline ::protobuf::Common* Line::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Line::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Line.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Line::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Line::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Line.common)
  return _msg;
}
inline void Line::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Line.common)
}

// .protobuf.Point start = 2;
inline bool Line::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void Line::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& Line::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Line::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Line.start)
  return _internal_start();
}
inline void Line::unsafe_arena_set_allocated_start(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Line.start)
}
inline ::protobuf::Point* Line::release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Line::unsafe_arena_release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Line.start)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Line::_internal_mutable_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.start_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.start_;
}
inline ::protobuf::Point* Line::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:protobuf.Line.start)
  return _msg;
}
inline void Line::set_allocated_start(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.start_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Line.start)
}

// .protobuf.Point end = 3;
inline bool Line::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void Line::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protobuf::Point& Line::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Line::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Line.end)
  return _internal_end();
}
inline void Line::unsafe_arena_set_allocated_end(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Line.end)
}
inline ::protobuf::Point* Line::release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protobuf::Point* released = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Line::unsafe_arena_release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Line.end)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protobuf::Point* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Line::_internal_mutable_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.end_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.end_;
}
inline ::protobuf::Point* Line::mutable_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:protobuf.Line.end)
  return _msg;
}
inline void Line::set_allocated_end(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.end_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Line.end)
}

// -------------------------------------------------------------------

// Circle

// .protobuf.Common common = 1;
inline bool Circle::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Circle::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Circle::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Circle::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Circle.common)
  return _internal_common();
}
inline void Circle::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Circle.common)
}
inline ::protobuf::Common* Circle::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Circle::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Circle.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Circle::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Circle::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Circle.common)
  return _msg;
}
inline void Circle::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Circle.common)
}

// .protobuf.Point center = 2;
inline bool Circle::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void Circle::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& Circle::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Circle::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Circle.center)
  return _internal_center();
}
inline void Circle::unsafe_arena_set_allocated_center(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Circle.center)
}
inline ::protobuf::Point* Circle::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Circle::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Circle.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Circle::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.center_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.center_;
}
inline ::protobuf::Point* Circle::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protobuf.Circle.center)
  return _msg;
}
inline void Circle::set_allocated_center(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Circle.center)
}

// float radius = 3;
inline void Circle::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float Circle::radius() const {
  // @@protoc_insertion_point(field_get:protobuf.Circle.radius)
  return _internal_radius();
}
inline void Circle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:protobuf.Circle.radius)
}
inline float Circle::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void Circle::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// Triangle

// .protobuf.Common common = 1;
inline bool Triangle::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Triangle::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Triangle::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Triangle::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Triangle.common)
  return _internal_common();
}
inline void Triangle::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Triangle.common)
}
inline ::protobuf::Common* Triangle::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Triangle::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Triangle.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Triangle::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Triangle::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Triangle.common)
  return _msg;
}
inline void Triangle::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Triangle.common)
}

// .protobuf.Point point1 = 2;
inline bool Triangle::has_point1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point1_ != nullptr);
  return value;
}
inline void Triangle::clear_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point1_ != nullptr) _impl_.point1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& Triangle::_internal_point1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.point1_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Triangle::point1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Triangle.point1)
  return _internal_point1();
}
inline void Triangle::unsafe_arena_set_allocated_point1(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point1_);
  }
  _impl_.point1_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Triangle.point1)
}
inline ::protobuf::Point* Triangle::release_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.point1_;
  _impl_.point1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Triangle::unsafe_arena_release_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Triangle.point1)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.point1_;
  _impl_.point1_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Triangle::_internal_mutable_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.point1_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.point1_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.point1_;
}
inline ::protobuf::Point* Triangle::mutable_point1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_point1();
  // @@protoc_insertion_point(field_mutable:protobuf.Triangle.point1)
  return _msg;
}
inline void Triangle::set_allocated_point1(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.point1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.point1_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Triangle.point1)
}

// .protobuf.Point point2 = 3;
inline bool Triangle::has_point2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point2_ != nullptr);
  return value;
}
inline void Triangle::clear_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point2_ != nullptr) _impl_.point2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protobuf::Point& Triangle::_internal_point2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.point2_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Triangle::point2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Triangle.point2)
  return _internal_point2();
}
inline void Triangle::unsafe_arena_set_allocated_point2(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point2_);
  }
  _impl_.point2_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Triangle.point2)
}
inline ::protobuf::Point* Triangle::release_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protobuf::Point* released = _impl_.point2_;
  _impl_.point2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Triangle::unsafe_arena_release_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Triangle.point2)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protobuf::Point* temp = _impl_.point2_;
  _impl_.point2_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Triangle::_internal_mutable_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.point2_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.point2_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.point2_;
}
inline ::protobuf::Point* Triangle::mutable_point2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_point2();
  // @@protoc_insertion_point(field_mutable:protobuf.Triangle.point2)
  return _msg;
}
inline void Triangle::set_allocated_point2(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.point2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.point2_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Triangle.point2)
}

// .protobuf.Point point3 = 4;
inline bool Triangle::has_point3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point3_ != nullptr);
  return value;
}
inline void Triangle::clear_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point3_ != nullptr) _impl_.point3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protobuf::Point& Triangle::_internal_point3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.point3_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Triangle::point3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Triangle.point3)
  return _internal_point3();
}
inline void Triangle::unsafe_arena_set_allocated_point3(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point3_);
  }
  _impl_.point3_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Triangle.point3)
}
inline ::protobuf::Point* Triangle::release_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protobuf::Point* released = _impl_.point3_;
  _impl_.point3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Triangle::unsafe_arena_release_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Triangle.point3)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protobuf::Point* temp = _impl_.point3_;
  _impl_.point3_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Triangle::_internal_mutable_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.point3_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.point3_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.point3_;
}
inline ::protobuf::Point* Triangle::mutable_point3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_point3();
  // @@protoc_insertion_point(field_mutable:protobuf.Triangle.point3)
  return _msg;
}
inline void Triangle::set_allocated_point3(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.point3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.point3_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Triangle.point3)
}

// -------------------------------------------------------------------

// Square

// .protobuf.Common common = 1;
inline bool Square::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Square::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Square::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Square::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Square.common)
  return _internal_common();
}
inline void Square::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Square.common)
}
inline ::protobuf::Common* Square::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Square::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Square.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Square::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Square::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Square.common)
  return _msg;
}
inline void Square::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Square.common)
}

// .protobuf.Point topleft = 2;
inline bool Square::has_topleft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.topleft_ != nullptr);
  return value;
}
inline void Square::clear_topleft() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.topleft_ != nullptr) _impl_.topleft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& Square::_internal_topleft() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.topleft_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Square::topleft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Square.topleft)
  return _internal_topleft();
}
inline void Square::unsafe_arena_set_allocated_topleft(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.topleft_);
  }
  _impl_.topleft_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Square.topleft)
}
inline ::protobuf::Point* Square::release_topleft() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.topleft_;
  _impl_.topleft_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Square::unsafe_arena_release_topleft() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Square.topleft)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.topleft_;
  _impl_.topleft_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Square::_internal_mutable_topleft() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.topleft_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.topleft_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.topleft_;
}
inline ::protobuf::Point* Square::mutable_topleft() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_topleft();
  // @@protoc_insertion_point(field_mutable:protobuf.Square.topleft)
  return _msg;
}
inline void Square::set_allocated_topleft(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.topleft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.topleft_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Square.topleft)
}

// float side_length = 3;
inline void Square::clear_side_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_length_ = 0;
}
inline float Square::side_length() const {
  // @@protoc_insertion_point(field_get:protobuf.Square.side_length)
  return _internal_side_length();
}
inline void Square::set_side_length(float value) {
  _internal_set_side_length(value);
  // @@protoc_insertion_point(field_set:protobuf.Square.side_length)
}
inline float Square::_internal_side_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.side_length_;
}
inline void Square::_internal_set_side_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_length_ = value;
}

// -------------------------------------------------------------------

// Text

// .protobuf.Common common = 1;
inline bool Text::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Text::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Text::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Text::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Text.common)
  return _internal_common();
}
inline void Text::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Text.common)
}
inline ::protobuf::Common* Text::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Text::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Text.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Text::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Text::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Text.common)
  return _msg;
}
inline void Text::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Text.common)
}

// .protobuf.Point center = 2;
inline bool Text::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void Text::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& Text::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Text::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Text.center)
  return _internal_center();
}
inline void Text::unsafe_arena_set_allocated_center(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Text.center)
}
inline ::protobuf::Point* Text::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Text::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Text.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Text::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.center_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.center_;
}
inline ::protobuf::Point* Text::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protobuf.Text.center)
  return _msg;
}
inline void Text::set_allocated_center(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Text.center)
}

// string content = 3;
inline void Text::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Text::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Text.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Text::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Text.content)
}
inline std::string* Text::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:protobuf.Text.content)
  return _s;
}
inline const std::string& Text::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void Text::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Text::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Text::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Text.content)
  return _impl_.content_.Release();
}
inline void Text::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Text.content)
}

// -------------------------------------------------------------------

// Comment

// string user_id = 1;
inline void Comment::clear_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Comment::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Comment.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Comment::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Comment.user_id)
}
inline std::string* Comment::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:protobuf.Comment.user_id)
  return _s;
}
inline const std::string& Comment::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void Comment::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* Comment::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* Comment::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Comment.user_id)
  return _impl_.user_id_.Release();
}
inline void Comment::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Comment.user_id)
}

// string content = 2;
inline void Comment::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Comment::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Comment.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Comment::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Comment.content)
}
inline std::string* Comment::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:protobuf.Comment.content)
  return _s;
}
inline const std::string& Comment::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void Comment::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Comment::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Comment::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Comment.content)
  return _impl_.content_.Release();
}
inline void Comment::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Comment.content)
}

// -------------------------------------------------------------------

// Picture

// .protobuf.Common common = 1;
inline bool Picture::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void Picture::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& Picture::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& Picture::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Picture.common)
  return _internal_common();
}
inline void Picture::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Picture.common)
}
inline ::protobuf::Common* Picture::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* Picture::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Picture.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* Picture::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* Picture::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.Picture.common)
  return _msg;
}
inline void Picture::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Picture.common)
}

// string file_name = 2;
inline void Picture::clear_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& Picture::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Picture.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Picture::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Picture.file_name)
}
inline std::string* Picture::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:protobuf.Picture.file_name)
  return _s;
}
inline const std::string& Picture::_internal_file_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.file_name_.Get();
}
inline void Picture::_internal_set_file_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.file_name_.Set(value, GetArena());
}
inline std::string* Picture::_internal_mutable_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.file_name_.Mutable( GetArena());
}
inline std::string* Picture::release_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Picture.file_name)
  return _impl_.file_name_.Release();
}
inline void Picture::set_allocated_file_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.file_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_name_.IsDefault()) {
          _impl_.file_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Picture.file_name)
}

// .protobuf.Point center = 3;
inline bool Picture::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void Picture::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& Picture::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& Picture::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Picture.center)
  return _internal_center();
}
inline void Picture::unsafe_arena_set_allocated_center(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Picture.center)
}
inline ::protobuf::Point* Picture::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* Picture::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Picture.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protobuf::Point* Picture::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.center_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.center_;
}
inline ::protobuf::Point* Picture::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protobuf.Picture.center)
  return _msg;
}
inline void Picture::set_allocated_center(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.Picture.center)
}

// float top_side_length = 4;
inline void Picture::clear_top_side_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_side_length_ = 0;
}
inline float Picture::top_side_length() const {
  // @@protoc_insertion_point(field_get:protobuf.Picture.top_side_length)
  return _internal_top_side_length();
}
inline void Picture::set_top_side_length(float value) {
  _internal_set_top_side_length(value);
  // @@protoc_insertion_point(field_set:protobuf.Picture.top_side_length)
}
inline float Picture::_internal_top_side_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_side_length_;
}
inline void Picture::_internal_set_top_side_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_side_length_ = value;
}

// bytes data = 5;
inline void Picture::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Picture::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Picture.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Picture::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.Picture.data)
}
inline std::string* Picture::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protobuf.Picture.data)
  return _s;
}
inline const std::string& Picture::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void Picture::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Picture::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Picture::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.Picture.data)
  return _impl_.data_.Release();
}
inline void Picture::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.Picture.data)
}

// repeated .protobuf.Comment comments = 6;
inline int Picture::_internal_comments_size() const {
  return _internal_comments().size();
}
inline int Picture::comments_size() const {
  return _internal_comments_size();
}
inline void Picture::clear_comments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comments_.Clear();
}
inline ::protobuf::Comment* Picture::mutable_comments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protobuf.Picture.comments)
  return _internal_mutable_comments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protobuf::Comment>* Picture::mutable_comments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protobuf.Picture.comments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_comments();
}
inline const ::protobuf::Comment& Picture::comments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Picture.comments)
  return _internal_comments().Get(index);
}
inline ::protobuf::Comment* Picture::add_comments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protobuf::Comment* _add = _internal_mutable_comments()->Add();
  // @@protoc_insertion_point(field_add:protobuf.Picture.comments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protobuf::Comment>& Picture::comments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protobuf.Picture.comments)
  return _internal_comments();
}
inline const ::google::protobuf::RepeatedPtrField<::protobuf::Comment>&
Picture::_internal_comments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comments_;
}
inline ::google::protobuf::RepeatedPtrField<::protobuf::Comment>*
Picture::_internal_mutable_comments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.comments_;
}

// -------------------------------------------------------------------

// StickyNote

// .protobuf.Common common = 1;
inline bool StickyNote::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void StickyNote::clear_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protobuf::Common& StickyNote::_internal_common() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Common* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Common&>(::protobuf::_Common_default_instance_);
}
inline const ::protobuf::Common& StickyNote::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.StickyNote.common)
  return _internal_common();
}
inline void StickyNote::unsafe_arena_set_allocated_common(::protobuf::Common* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.StickyNote.common)
}
inline ::protobuf::Common* StickyNote::release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* released = _impl_.common_;
  _impl_.common_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Common* StickyNote::unsafe_arena_release_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.StickyNote.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protobuf::Common* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::protobuf::Common* StickyNote::_internal_mutable_common() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.common_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Common>(GetArena());
    _impl_.common_ = reinterpret_cast<::protobuf::Common*>(p);
  }
  return _impl_.common_;
}
inline ::protobuf::Common* StickyNote::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Common* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:protobuf.StickyNote.common)
  return _msg;
}
inline void StickyNote::set_allocated_common(::protobuf::Common* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Common*>(_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Common*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::protobuf::Common*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.StickyNote.common)
}

// .protobuf.Point center = 2;
inline bool StickyNote::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void StickyNote::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protobuf::Point& StickyNote::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protobuf::Point* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuf::Point&>(::protobuf::_Point_default_instance_);
}
inline const ::protobuf::Point& StickyNote::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.StickyNote.center)
  return _internal_center();
}
inline void StickyNote::unsafe_arena_set_allocated_center(::protobuf::Point* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.StickyNote.center)
}
inline ::protobuf::Point* StickyNote::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protobuf::Point* StickyNote::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.StickyNote.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protobuf::Point* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protobuf::Point* StickyNote::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuf::Point>(GetArena());
    _impl_.center_ = reinterpret_cast<::protobuf::Point*>(p);
  }
  return _impl_.center_;
}
inline ::protobuf::Point* StickyNote::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Point* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protobuf.StickyNote.center)
  return _msg;
}
inline void StickyNote::set_allocated_center(::protobuf::Point* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protobuf::Point*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protobuf::Point*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::protobuf::Point*>(value);
  // @@protoc_insertion_point(field_set_allocated:protobuf.StickyNote.center)
}

// float side_length = 3;
inline void StickyNote::clear_side_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_length_ = 0;
}
inline float StickyNote::side_length() const {
  // @@protoc_insertion_point(field_get:protobuf.StickyNote.side_length)
  return _internal_side_length();
}
inline void StickyNote::set_side_length(float value) {
  _internal_set_side_length(value);
  // @@protoc_insertion_point(field_set:protobuf.StickyNote.side_length)
}
inline float StickyNote::_internal_side_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.side_length_;
}
inline void StickyNote::_internal_set_side_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_length_ = value;
}

// string content = 4;
inline void StickyNote::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& StickyNote::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.StickyNote.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StickyNote::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protobuf.StickyNote.content)
}
inline std::string* StickyNote::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:protobuf.StickyNote.content)
  return _s;
}
inline const std::string& StickyNote::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void StickyNote::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* StickyNote::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* StickyNote::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protobuf.StickyNote.content)
  return _impl_.content_.Release();
}
inline void StickyNote::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.StickyNote.content)
}

// -------------------------------------------------------------------

// Element

// .protobuf.Path path = 1;
inline bool Element::has_path() const {
  return element_type_case() == kPath;
}
inline bool Element::_internal_has_path() const {
  return element_type_case() == kPath;
}
inline void Element::set_has_path() {
  _impl_._oneof_case_[0] = kPath;
}
inline void Element::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kPath) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.path_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Path* Element::release_path() {
  // @@protoc_insertion_point(field_release:protobuf.Element.path)
  if (element_type_case() == kPath) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.path_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Path& Element::_internal_path() const {
  return element_type_case() == kPath ? *_impl_.element_type_.path_ : reinterpret_cast<::protobuf::Path&>(::protobuf::_Path_default_instance_);
}
inline const ::protobuf::Path& Element::path() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.path)
  return _internal_path();
}
inline ::protobuf::Path* Element::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.path)
  if (element_type_case() == kPath) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.path_;
    _impl_.element_type_.path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_path(::protobuf::Path* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_path();
    _impl_.element_type_.path_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.path)
}
inline ::protobuf::Path* Element::_internal_mutable_path() {
  if (element_type_case() != kPath) {
    clear_element_type();
    set_has_path();
    _impl_.element_type_.path_ = CreateMaybeMessage<::protobuf::Path>(GetArena());
  }
  return _impl_.element_type_.path_;
}
inline ::protobuf::Path* Element::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.path)
  return _msg;
}

// .protobuf.Line line = 2;
inline bool Element::has_line() const {
  return element_type_case() == kLine;
}
inline bool Element::_internal_has_line() const {
  return element_type_case() == kLine;
}
inline void Element::set_has_line() {
  _impl_._oneof_case_[0] = kLine;
}
inline void Element::clear_line() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kLine) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.line_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Line* Element::release_line() {
  // @@protoc_insertion_point(field_release:protobuf.Element.line)
  if (element_type_case() == kLine) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.line_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Line& Element::_internal_line() const {
  return element_type_case() == kLine ? *_impl_.element_type_.line_ : reinterpret_cast<::protobuf::Line&>(::protobuf::_Line_default_instance_);
}
inline const ::protobuf::Line& Element::line() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.line)
  return _internal_line();
}
inline ::protobuf::Line* Element::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.line)
  if (element_type_case() == kLine) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.line_;
    _impl_.element_type_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_line(::protobuf::Line* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_line();
    _impl_.element_type_.line_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.line)
}
inline ::protobuf::Line* Element::_internal_mutable_line() {
  if (element_type_case() != kLine) {
    clear_element_type();
    set_has_line();
    _impl_.element_type_.line_ = CreateMaybeMessage<::protobuf::Line>(GetArena());
  }
  return _impl_.element_type_.line_;
}
inline ::protobuf::Line* Element::mutable_line() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Line* _msg = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.line)
  return _msg;
}

// .protobuf.Circle circle = 3;
inline bool Element::has_circle() const {
  return element_type_case() == kCircle;
}
inline bool Element::_internal_has_circle() const {
  return element_type_case() == kCircle;
}
inline void Element::set_has_circle() {
  _impl_._oneof_case_[0] = kCircle;
}
inline void Element::clear_circle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kCircle) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.circle_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Circle* Element::release_circle() {
  // @@protoc_insertion_point(field_release:protobuf.Element.circle)
  if (element_type_case() == kCircle) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.circle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Circle& Element::_internal_circle() const {
  return element_type_case() == kCircle ? *_impl_.element_type_.circle_ : reinterpret_cast<::protobuf::Circle&>(::protobuf::_Circle_default_instance_);
}
inline const ::protobuf::Circle& Element::circle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.circle)
  return _internal_circle();
}
inline ::protobuf::Circle* Element::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.circle)
  if (element_type_case() == kCircle) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.circle_;
    _impl_.element_type_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_circle(::protobuf::Circle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_circle();
    _impl_.element_type_.circle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.circle)
}
inline ::protobuf::Circle* Element::_internal_mutable_circle() {
  if (element_type_case() != kCircle) {
    clear_element_type();
    set_has_circle();
    _impl_.element_type_.circle_ = CreateMaybeMessage<::protobuf::Circle>(GetArena());
  }
  return _impl_.element_type_.circle_;
}
inline ::protobuf::Circle* Element::mutable_circle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Circle* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.circle)
  return _msg;
}

// .protobuf.Triangle triangle = 4;
inline bool Element::has_triangle() const {
  return element_type_case() == kTriangle;
}
inline bool Element::_internal_has_triangle() const {
  return element_type_case() == kTriangle;
}
inline void Element::set_has_triangle() {
  _impl_._oneof_case_[0] = kTriangle;
}
inline void Element::clear_triangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kTriangle) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.triangle_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Triangle* Element::release_triangle() {
  // @@protoc_insertion_point(field_release:protobuf.Element.triangle)
  if (element_type_case() == kTriangle) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.triangle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Triangle& Element::_internal_triangle() const {
  return element_type_case() == kTriangle ? *_impl_.element_type_.triangle_ : reinterpret_cast<::protobuf::Triangle&>(::protobuf::_Triangle_default_instance_);
}
inline const ::protobuf::Triangle& Element::triangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.triangle)
  return _internal_triangle();
}
inline ::protobuf::Triangle* Element::unsafe_arena_release_triangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.triangle)
  if (element_type_case() == kTriangle) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.triangle_;
    _impl_.element_type_.triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_triangle(::protobuf::Triangle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_triangle();
    _impl_.element_type_.triangle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.triangle)
}
inline ::protobuf::Triangle* Element::_internal_mutable_triangle() {
  if (element_type_case() != kTriangle) {
    clear_element_type();
    set_has_triangle();
    _impl_.element_type_.triangle_ = CreateMaybeMessage<::protobuf::Triangle>(GetArena());
  }
  return _impl_.element_type_.triangle_;
}
inline ::protobuf::Triangle* Element::mutable_triangle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Triangle* _msg = _internal_mutable_triangle();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.triangle)
  return _msg;
}

// .protobuf.Square square = 5;
inline bool Element::has_square() const {
  return element_type_case() == kSquare;
}
inline bool Element::_internal_has_square() const {
  return element_type_case() == kSquare;
}
inline void Element::set_has_square() {
  _impl_._oneof_case_[0] = kSquare;
}
inline void Element::clear_square() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kSquare) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.square_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Square* Element::release_square() {
  // @@protoc_insertion_point(field_release:protobuf.Element.square)
  if (element_type_case() == kSquare) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.square_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.square_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Square& Element::_internal_square() const {
  return element_type_case() == kSquare ? *_impl_.element_type_.square_ : reinterpret_cast<::protobuf::Square&>(::protobuf::_Square_default_instance_);
}
inline const ::protobuf::Square& Element::square() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.square)
  return _internal_square();
}
inline ::protobuf::Square* Element::unsafe_arena_release_square() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.square)
  if (element_type_case() == kSquare) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.square_;
    _impl_.element_type_.square_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_square(::protobuf::Square* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_square();
    _impl_.element_type_.square_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.square)
}
inline ::protobuf::Square* Element::_internal_mutable_square() {
  if (element_type_case() != kSquare) {
    clear_element_type();
    set_has_square();
    _impl_.element_type_.square_ = CreateMaybeMessage<::protobuf::Square>(GetArena());
  }
  return _impl_.element_type_.square_;
}
inline ::protobuf::Square* Element::mutable_square() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Square* _msg = _internal_mutable_square();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.square)
  return _msg;
}

// .protobuf.Text text = 6;
inline bool Element::has_text() const {
  return element_type_case() == kText;
}
inline bool Element::_internal_has_text() const {
  return element_type_case() == kText;
}
inline void Element::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void Element::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kText) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.text_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Text* Element::release_text() {
  // @@protoc_insertion_point(field_release:protobuf.Element.text)
  if (element_type_case() == kText) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.text_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Text& Element::_internal_text() const {
  return element_type_case() == kText ? *_impl_.element_type_.text_ : reinterpret_cast<::protobuf::Text&>(::protobuf::_Text_default_instance_);
}
inline const ::protobuf::Text& Element::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.text)
  return _internal_text();
}
inline ::protobuf::Text* Element::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.text)
  if (element_type_case() == kText) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.text_;
    _impl_.element_type_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_text(::protobuf::Text* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_text();
    _impl_.element_type_.text_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.text)
}
inline ::protobuf::Text* Element::_internal_mutable_text() {
  if (element_type_case() != kText) {
    clear_element_type();
    set_has_text();
    _impl_.element_type_.text_ = CreateMaybeMessage<::protobuf::Text>(GetArena());
  }
  return _impl_.element_type_.text_;
}
inline ::protobuf::Text* Element::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Text* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.text)
  return _msg;
}

// .protobuf.Picture picture = 7;
inline bool Element::has_picture() const {
  return element_type_case() == kPicture;
}
inline bool Element::_internal_has_picture() const {
  return element_type_case() == kPicture;
}
inline void Element::set_has_picture() {
  _impl_._oneof_case_[0] = kPicture;
}
inline void Element::clear_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kPicture) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.picture_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::Picture* Element::release_picture() {
  // @@protoc_insertion_point(field_release:protobuf.Element.picture)
  if (element_type_case() == kPicture) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.picture_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.picture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::Picture& Element::_internal_picture() const {
  return element_type_case() == kPicture ? *_impl_.element_type_.picture_ : reinterpret_cast<::protobuf::Picture&>(::protobuf::_Picture_default_instance_);
}
inline const ::protobuf::Picture& Element::picture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.picture)
  return _internal_picture();
}
inline ::protobuf::Picture* Element::unsafe_arena_release_picture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.picture)
  if (element_type_case() == kPicture) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.picture_;
    _impl_.element_type_.picture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_picture(::protobuf::Picture* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_picture();
    _impl_.element_type_.picture_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.picture)
}
inline ::protobuf::Picture* Element::_internal_mutable_picture() {
  if (element_type_case() != kPicture) {
    clear_element_type();
    set_has_picture();
    _impl_.element_type_.picture_ = CreateMaybeMessage<::protobuf::Picture>(GetArena());
  }
  return _impl_.element_type_.picture_;
}
inline ::protobuf::Picture* Element::mutable_picture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::Picture* _msg = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.picture)
  return _msg;
}

// .protobuf.StickyNote stickynote = 8;
inline bool Element::has_stickynote() const {
  return element_type_case() == kStickynote;
}
inline bool Element::_internal_has_stickynote() const {
  return element_type_case() == kStickynote;
}
inline void Element::set_has_stickynote() {
  _impl_._oneof_case_[0] = kStickynote;
}
inline void Element::clear_stickynote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (element_type_case() == kStickynote) {
    if (GetArena() == nullptr) {
      delete _impl_.element_type_.stickynote_;
    }
    clear_has_element_type();
  }
}
inline ::protobuf::StickyNote* Element::release_stickynote() {
  // @@protoc_insertion_point(field_release:protobuf.Element.stickynote)
  if (element_type_case() == kStickynote) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.stickynote_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.element_type_.stickynote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protobuf::StickyNote& Element::_internal_stickynote() const {
  return element_type_case() == kStickynote ? *_impl_.element_type_.stickynote_ : reinterpret_cast<::protobuf::StickyNote&>(::protobuf::_StickyNote_default_instance_);
}
inline const ::protobuf::StickyNote& Element::stickynote() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protobuf.Element.stickynote)
  return _internal_stickynote();
}
inline ::protobuf::StickyNote* Element::unsafe_arena_release_stickynote() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protobuf.Element.stickynote)
  if (element_type_case() == kStickynote) {
    clear_has_element_type();
    auto* temp = _impl_.element_type_.stickynote_;
    _impl_.element_type_.stickynote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Element::unsafe_arena_set_allocated_stickynote(::protobuf::StickyNote* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_element_type();
  if (value) {
    set_has_stickynote();
    _impl_.element_type_.stickynote_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuf.Element.stickynote)
}
inline ::protobuf::StickyNote* Element::_internal_mutable_stickynote() {
  if (element_type_case() != kStickynote) {
    clear_element_type();
    set_has_stickynote();
    _impl_.element_type_.stickynote_ = CreateMaybeMessage<::protobuf::StickyNote>(GetArena());
  }
  return _impl_.element_type_.stickynote_;
}
inline ::protobuf::StickyNote* Element::mutable_stickynote() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protobuf::StickyNote* _msg = _internal_mutable_stickynote();
  // @@protoc_insertion_point(field_mutable:protobuf.Element.stickynote)
  return _msg;
}

inline bool Element::has_element_type() const {
  return element_type_case() != ELEMENT_TYPE_NOT_SET;
}
inline void Element::clear_has_element_type() {
  _impl_._oneof_case_[0] = ELEMENT_TYPE_NOT_SET;
}
inline Element::ElementTypeCase Element::element_type_case() const {
  return Element::ElementTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_element_2eproto_2epb_2eh
